##Packages 
require(igraph)
require(ggplot2)
require(dplyr)
require(tidyr)
require(RColorBrewer)
require(bipartite) 
require(bbmle)
require(influential)





# -----------------------------
# 1. Build the Graph (directed)
# -----------------------------
cat("\n--- 1. Creating Directed Graph of Judo Attack Combinations ---\n")

# Define the attack combinations using igraph's formula notation
# Using -+ for DIRECTED edges (from first to second technique)
attack_combinations_igraph=graph.formula(
  Seoi.nage-+Seoi.otoshi,
  Seoi.nage-+O.uchi.gari,
  Seoi.nage-+Ko.uchi.gari,
  Ippon.seoi.nage-+Ippon.seoi.nage,
  Ippon.seoi.nage-+Seoi.otoshi,
  Ippon.seoi.nage-+Ko.uchi.gari,
  Ippon.seoi.nage-+Osoto.gari,
  Harai.goshi-+Osoto.gari,
  Harai.goshi-+Uchi.mata,
  Harai.goshi-+Soto.makikomi,
  Uchi.mata-+O.uchi.gari,
  Uchi.mata-+Ko.uchi.gari,
  O.goshi-+O.uchi.gari,
  O.goshi-+Ko.uchi.gari,
  O.goshi-+Harai.goshi,
  O.uchi.gari-+Uchi.mata,
  O.uchi.gari-+Ko.uchi.gari,
  O.uchi.gari-+Osoto.gari,
  O.uchi.gari-+Tai.otoshi,
  O.uchi.gari-+Harai.goshi,
  Ko.uchi.gari-+O.uchi.gari,
  Ko.uchi.gari-+Seoi.nage,
  Ko.uchi.gari-+Ippon.seoi.nage,
  Ko.uchi.gari-+Hane.goshi,
  Osoto.gari-+Harai.goshi,
  Osoto.gari-+Osoto.gari,
  Osoto.gari-+O.uchi.gari,
  Osoto.gari-+Ko.soto.gake,
  Osoto.gari-+Sasae.tsurikomi.ashi,
  Osoto.gari-+Okuri.ashi.harai,
  Osoto.gari-+Hiza.guruma,
  Ko.soto.gari-+Ko.soto.gari,
  Ko.soto.gari-+Osoto.gari,
  Ko.soto.gari-+Tai.otoshi,
  Ko.soto.gari-+Harai.goshi,
  Hiza.guruma-+Harai.goshi,
  Hiza.guruma-+Sasae.tsurikomi.ashi,
  Hiza.guruma-+Osoto.gari,
  Hiza.guruma-+De.ashi.harai,
  Hiza.guruma-+Hiza.guruma,
  Okuri.ashi.harai-+Sode.tsuri.komi.goshi,
  Okuri.ashi.harai-+Tai.otoshi,
  Okuri.ashi.harai-+Harai.goshi,
  Okuri.ashi.harai-+Ippon.seoi.nage,
  Okuri.ashi.harai-+Seoi.nage,
  Tai.otoshi-+Tai.otoshi,
  Tai.otoshi-+Ko.uchi.gari,
  Tai.otoshi-+O.uchi.gari,
  Hikikomi.gaeshi-+O.uchi.gari,
  Hikikomi.gaeshi-+Ko.uchi.gari,
  Hikikomi.gaeshi-+Harai.goshi,
  Hikikomi.gaeshi-+Ko.soto.gari,
  Hikikomi.gaeshi-+Sukui.nage,
  Tsuri.komi.goshi-+O.uchi.gari,
  Tsuri.komi.goshi-+Sode.tsuri.komi.goshi,
  Tsuri.komi.goshi-+Tsuri.komi.goshi,
  Hane.goshi-+O.uchi.gari,
  Sasae.tsurikomi.ashi-+Uchi.mata,
  Sasae.tsurikomi.ashi-+Tai.otoshi
)

# 1. Calculate Degrees
node_names <- V(attack_combinations_igraph)$name
in_degree <- igraph::degree(attack_combinations_igraph, mode = "in")
out_degree <- igraph::degree(attack_combinations_igraph, mode = "out")
total_degree <- igraph::degree(attack_combinations_igraph, mode = "all")

# Create a data frame for plotting
degree_df <- data.frame(
  Technique = node_names,
  InDegree = in_degree,
  OutDegree = out_degree,
  TotalDegree = total_degree
)

# Print the degree data
print("Degree Data for each Technique:")
print(degree_df)

# --- Plot 1: Bar plot of In, Out, and Total Degrees for each technique ---

# Reshape data to long format for ggplot
degree_df_long <- degree_df %>%
  pivot_longer(cols = c(InDegree, OutDegree),
               names_to = "DegreeType",
               values_to = "DegreeValue") %>%
  mutate(DegreeType = factor(DegreeType, levels = c("InDegree", "OutDegree"))) # Control order

# Make technique names more readable if too long by adding newlines (optional)
# This is a bit manual, you might need to adjust based on your actual names
# degree_df_long$Technique_label <- gsub("\\.", ".\\n", degree_df_long$Technique)
# For this example, standard names are okay.

degree_plot <- ggplot(degree_df_long, aes(x = reorder(Technique, -DegreeValue), y = DegreeValue, fill = DegreeType)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  scale_fill_brewer(palette = "Set2", name = "Degree Type", labels = c("In-Degree", "Out-Degree")) +
  labs(
    title = "Judo Technique Combination Degrees",
    subtitle = "In-degree: how often a technique is a follow-up.\nOut-degree: how often a technique initiates a combination.",
    x = "Judo Technique",
    y = "Degree Count"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 65, hjust = 1, vjust = 1, size = 9),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "top",
    panel.grid.major.x = element_blank(), # Remove vertical grid lines for cleaner look
    panel.grid.minor.y = element_blank()
  ) +
  geom_text(aes(label=ifelse(DegreeValue > 0, DegreeValue, "")), 
            position=position_dodge(width=0.9), vjust=-0.25, size=2.5)


print(degree_plot)


# --- Plot 2: Cumulative Degree Distribution Plot (for Total Degree) ---
# Load required libraries

# Compute cumulative degree distribution
deg <- degree_distribution(attack_combinations_igraph, cumulative = TRUE, mode = "all")
deg_table <- data.frame(
  Degree = 0:(length(deg) - 1),
  CumulativeProbability = deg
)

# 2. Remove zeros (nls can't handle log(0) or fit to 0)
deg_table <- deg_table[deg_table$Degree > 0 & deg_table$CumulativeProbability > 0, ]

# 3. Fit power-law model: P(k) = a * k^(-b)
pl_model <- nls(CumulativeProbability ~ a * Degree^(-b),
                data = deg_table,
                start = list(a = 1, b = 2),
                control = nls.control(warnOnly = TRUE))

# 4. Fit exponential model: P(k) = a * exp(-b * k)
exp_model <- nls(CumulativeProbability ~ a * exp(-b * Degree),
                 data = deg_table,
                 start = list(a = 1, b = 0.1),
                 control = nls.control(warnOnly = TRUE))

# 5. Fit truncated power-law: P(k) = a * k^(-b) * exp(-c * k)
tpl_model <- nls(CumulativeProbability ~ a * Degree^(-b) * exp(-c * Degree),
                 data = deg_table,
                 start = list(a = 1, b = 1.5, c = 0.05),
                 control = nls.control(warnOnly = TRUE))
# 6. Compare models using AIC
AICctab(pl_model,exp_model,tpl_model,nobs=length(deg),weights = TRUE, delta = TRUE, base = TRUE)

# --- Plot Cumulative Distribution and Model Fits (log-log scale) ---
plot(deg_table$Degree, deg_table$CumulativeProbability, 
     log = "xy", pch = 16,
     xlab = "Degree", ylab = "P(K ≥ k)", 
     main = "Cumulative Degree Distribution (log-log)")

curve(coef(pl_model)[1] * x^(-coef(pl_model)[2]), 
      add = TRUE, col = "blue", lwd = 2)
curve(coef(exp_model)[1] * exp(-coef(exp_model)[2] * x), 
      add = TRUE, col = "red", lwd = 2)
curve(coef(tpl_model)[1] * x^(-coef(tpl_model)[2]) * exp(-coef(tpl_model)[3] * x), 
      add = TRUE, col = "darkgreen", lwd = 2)

legend("bottomleft", legend = c("Power-law", "Exponential", "Truncated PL"),
       col = c("blue", "red", "darkgreen"), lwd = 2)

# Compute IVI
Graph_IVI <- ivi(attack_combinations_igraph, mode = "all")

# Plot IVI using cent_network.vis (supported arguments only)
cent_network.vis(
  graph = attack_combinations_igraph,
  cent.metric = Graph_IVI,
  legend.title = "IVI",
  plot.title = "Attack Combination Network – IVI",
  layout = "kk",                  # Kamada-Kawai layout
  dist.power = 1.5,
  legend.position = "right",
  boxed.legend = TRUE,
  show.labels = TRUE              # You can toggle this
)
